---
title: 'Introduint "useLocalStorage", un hook de React per persistir l‚Äôestat'
publishedAt: '2023-09-21'
summary: "Un tutorial sobre com podem crear un hook personalitzat per emmagatzemar una part de l‚Äôestat de React al localStorage, i reinicialitzar des d‚Äôaquell valor al refrescar."
---

Suposem que creem una aplicaci√≥ que ofereix l‚Äôopci√≥ d‚Äôactivar el *dark mode* (mode fosc), com aquest blog. L‚Äôaplicaci√≥ ens permet canviar entre tres temes diferents: fosc ‚òæ, clar ‚òº i segons la configuraci√≥ del sistema üñ•Ô∏è.

<Image
  alt={"Airbnb"}
  src={"/images/persistint-estat-de-react-al-localstorage/theme.gif"}
  width={795}
  height={620}
  unoptimized={true}
/>

Personalment, jo sempre prefereixo veure les aplicacions en mode fosc. Les interf√≠cies fosques es visualitzen millor en la foscor, minimitzen la fatiga visual i solen ser minimalistes i elegants.

Per sort, les aplicacions saben que els usuaris tenim prefer√®ncies clares sobre aquest tipus de coses, i el canvi √©s persistent. Si canvio de mode clar a fosc i refresco la p√†gina, el fosc √©s el nou mode per defecte; persisteix.

Contr√†riament, √©s **s√∫per molest** que els controls dels formularis no siguin persistents. Per exemple, imagineu que cada cop que f√©ssiu una cerca d‚Äôuna destinaci√≥ a trav√©s d‚ÄôAirbnb o Booking hagu√©ssiu de tornar a introduir les dates d‚Äôarribada, de sortida i el nombre d‚Äôhostes... üò°

En aquest tutorial veurem com podem crear un *hook* personalitzat de React per abstreure la persist√®ncia, de manera de l‚Äôaconseguim sempre que la necessitem.

### Els fonaments

L‚Äôingredient principal que necessitem per persistir el nostre estat de React √©s el localStorage (emmagatzematge local).

Aix√≠ √©s com quedaria el nostre *hook* personalitzat:

```tsx
function useLocalStorage(defaultValue, key) {
  const [value, setValue] = React.useState(() => {
    const persistedValue = window.localStorage.getItem(key);
 
    return persistedValue !== null
      ? JSON.parse(persistedValue)
      : defaultValue;
  });
 
  React.useEffect(() => {
    window.localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);
 
  return [value, setValue];
}
```

Per veure com funciona, aqu√≠ teniu una demostraci√≥ senzilla amb un comptador persistent. Poveu a fer-hi uns quants clics i, a continuaci√≥, refresqueu aquesta p√†gina:

<Playground
  title="App.js"
  files={{
    "/hooks.js": {
      code: `import { useEffect, useState } from 'react';

export default function useLocalStorage(defaultValue, key) {
  const [value, setValue] = useState(() => {
    const persistedValue = window.localStorage.getItem(key);

    return persistedValue !== null
      ? JSON.parse(persistedValue)
      : defaultValue;
  });

  useEffect(() => {
    window.localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);
  
	return [value, setValue];
}
`,
      hidden: true,
    },
    "/App.js": `import useLocalStorage from './hooks.js';

function App() {
  const [count, setCount] = useLocalStorage(0, "count");

  return (
    <div className="App">
      <h1>React Counter</h1>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </div>
  );
}

export default App;
`
  }}
/>

<Callout emoji="‚ö†Ô∏è">
  **Qu√® passa amb el *server-side rendering* (SSR)?**

  Si utilitzeu SSR o un *framework* que l‚Äôutilitza (com Next.js) i feu servir aquest *hook* a p√®l, obtindreu el seg√ºent error: `ReferenceError: localStorage is not defined`

  Aix√≤ ocorre perqu√® el primer render en el servidor no t√© acc√©s al localStorage de la nostra m√†quina i, per tant, no pot saber quin hauria de ser el valor inicial.

  La soluci√≥ m√©s f√†cil seria utilitzar aquest *hook* nom√©s en components de la banda del client. Tamb√© podriem crear un altre *hook* per saber si l‚Äôaplicaci√≥ s‚Äôha muntat.

  Podeu llegir m√©s informaci√≥ sobre el contingut din√†mic d‚Äôuna aplicaci√≥ SSR en aquest article de Josh Comeau titulat ['The Perils of Hydration'](https://www.joshwcomeau.com/react/the-perils-of-rehydration/).
</Callout>

#### A la pr√†ctica

Aquest *hook* assumeix que el valor que alimenta els `<input>`,¬†`<textarea>`¬†i el `<select>` d‚Äôun formulari es guarda en un estat de React.

Per exemple, aqu√≠ teniu una implementaci√≥ no persistent d‚Äôun control de formulari per canviar entre valors:

```tsx
const ThemeToggle = () => {
  const [mode, setMode] = React.useState("system");
   
  return (
    <>
      <select onChange={ev => setMode(ev.target.value)}>
        <option value="light">üåû</option>
        <option value="dark">üåô</option>
        <option value="system">üñ•Ô∏è</option>
      </select>
    </>
  )
}
```

Podem fer servir la nostra nova variant persistent canviant el *hook*:

```tsx
const ThemeToggle = () => {
  const [mode, setMode] = useLocalStorage("", "theme");
 
  return (
    <>
      <select onChange={ev => setMode(ev.target.value)}>
        <option value="light">üåû</option>
        <option value="dark">üåô</option>
        <option value="system">üñ•Ô∏è</option>
      </select>
    </>
  )
}
```

S‚Äôutilitza exactament igual que el *hook* `useState`, per√≤ en comptes de rebre un argument, el nostre *hook* en rep dos: el valor inicial i un identificador. El segon argument s‚Äôutilitzar√† per obtenir i setejar el valor persistit al localStorage. √âs important que cada inst√†ncia del *hook* utilitzi un valor √∫nic, per√≤ a part d‚Äôaix√≤ pot ser qualsevol.

### Com funciona

B√†sicament, el nostre *hook* funciona com el `useState` i, a m√©s, afegeix el seg√ºent:

#### 1. Inicialitzaci√≥ *lazy*

El terme *lazy* significa, literalment, gandul. Aquest tipus d'inicialitzaci√≥ permet que l‚Äôobjecte no s‚Äôinstanci√Ø fins que es cridi per primer cop. Aix√≤ ens permet passar una funci√≥ en el `useState` en comptes d‚Äôun valor, i aquesta funci√≥ nom√©s s‚Äôexecutar√† quan es cre√Ø l'estat, el primer cop que es renderitzi el component.

```tsx
const [value, setValue] = React.useState(() => {
  const persistedValue = window.localStorage.getItem(key);
   
  return persistedValue !== null
    ? JSON.parse(persistedValue)
    : defaultValue;
});
```

En el nostre cas, l'utilitzem per comprovar el valor en el localStorage. Si el valor existeix, l‚Äôutilitzem com a valor inicial. Altrament, utilitzem el valor predeterminat passat al *hook* ("system", en el nostre exemple anterior).

#### 2. Manteniment de l‚Äôemmagatzematge local sincronitzat

Amb el `useEffect` ens assegurem d'actualitzar el localStorage sempre que canvi√Ø el valor de l‚Äôestat:

```tsx
React.useEffect(() => {
  window.localStorage.setItem(key, JSON.stringify(value));
}, [key, value]);
```

<Callout emoji="‚ö†Ô∏è">
  **Qu√® passa amb el rendiment?**

  Com que el localStorage √©s una API s√≠ncrona, pot causar problemes de rendiment si s‚Äôactualiza massa r√†pidament.
  
  Si el valor de l‚Äôestat canvia moltes vegades per segon, potser ens interessar√† accelerar o posposar les actualitzacions al localStorage.
</Callout>

### Desavantatges

La majoria de desavantatges del localStorage no semblen ser cr√≠tics, m√©s enll√† de disminuir una mica el rendiment de l'aplicaci√≥ o haver de perdre el temps serialitzant les dades (per m√©s informaci√≥, consulteu aquest article de Randall Degges titulat ["Please Stop Using Local Storage"](https://dev.to/rdegges/please-stop-using-local-storage-1i04)).

Dit aix√≤, hi ha un aspecte important: la seguretat. √âs important entendre que en cap cas el localStorage ha estat dissenyat com un mecanisme d‚Äôemmagatzematge segur en el navegador. M√©s aviat va ser pensat com un magatzem de parells clau/valor perqu√® els desenvolupadors fessin servir per crear aplicacions *single-page* un xic m√©s complexes.

El localStorage no s‚Äôhauria d‚Äôutilizar per desar informaci√≥ sensible com identificadors de sessi√≥/usuari, *JSON web tokens*, informaci√≥ personal, targetes de cr√®dit, *API keys* o res que no ens interessaria veure publicat a Twitter.

La vulnerabilitat rau sobretot en els atacs *cross-site scripting* (XSS) on l‚Äôatacant executa codi malici√≥s al navegador de l‚Äôusuari i pot robar totes les dades desades al localStorage, comprometent-les.

Per tant, per curar-vos en salut i redu√Ør el risc d‚Äôun incident de seguretat, encara que penseu que la vostra aplicaci√≥ √©s la m√©s segura del m√≥n, no emmagatzemeu res sensible al localStorage.

### Conclusi√≥

Aquest tutorial √©s un petit exemple de com els *hooks* personalitzats ens permeten crear les nostres pr√≤pies APIs per resoldre q√ºestions. Tot i que existeixen [llibreries](https://usehooks.com/uselocalstorage) que resolen aquest tipus de temes per nosaltres, crec que t√© valor que com a desenvolupadors trobem la soluci√≥ a aquests problemes per nosaltres mateixos.