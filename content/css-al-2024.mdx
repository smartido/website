---
title: 'CSS al 2024'
publishedAt: '2024-07-15'
summary: "Mai havia estat tan f√†cil com ara escriure estils amb CSS! Aquest article aprofundeix en l‚Äôecosistema de CSS i en quines eines ens poden ser √∫tils."
---

Els √∫ltims mesos han marcat l'inici d'una √®poca daurada per a la interf√≠cie d'usuari web. Els navegadors han adoptat noves capacitats de plataforma, afegint suport a m√©s funcions de personalitzaci√≥ üíÖ que mai.

Per exemple, algunes incorporacions amb m√©s impacte han estat les seg√ºents: [container queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_queries), [`:has()`](https://developer.chrome.com/blog/has-m105), [subgrid](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Subgrid), [dynamic viewport units](https://web.dev/blog/viewport-units), [color spaces](https://developer.chrome.com/blog/meet-the-new-css-color-spaces), [nesting](https://developer.chrome.com/docs/css-ui/css-nesting) i [cascade layers](https://developer.mozilla.org/en-US/docs/Web/CSS/@layer).

A m√©s, existeixen molts *frameworks* i compiladors per ajudar a optimitzar el rendiment de c√†rrega del CSS. I tamb√© hi ha moltes eines CSS for√ßa potents i r√†pides de les quals √©s probable que n‚Äôhagueu sentit parlar. ‚ú®

Aquesta entrada del blog √©s un recull dels meus apunts i reflexions sobre l'ecosistema CSS i les eines que estic utilizant actualment.

<Callout emoji="‚ÑπÔ∏è">
  **Informaci√≥**

  Aquest article est√† escrit per desenvolupadors front-end / full-stack. Concretament, pels que gaudeixen fent servir *frameworks* de JavaScript moderns com React i tenen curiositat per l‚Äôecosistema de CSS.
</Callout>


---

### Bones pr√†ctiques en CSS

Seguir bones pr√†ctiques alhora de crear estils amb CSS pot marcar una gran difer√®ncia en la rapidesa de c√†rrega, l'escalabilitat i la mantenibilitat de les vostres aplicacions web. ‚ö°

Aix√≤ es pot traduir tant en una millor experi√®ncia d'usuari (UX) com en una millor experi√®ncia de desenvolupador (DX).

Aqu√≠ teniu alguns punts que val la pena l'esfor√ß d'aconseguir:

- **Fitxers de mida petita** ‚Äî Els fulls d‚Äôestil s‚Äôhan de carregar el m√©s r√†pid possible. Com m√©s gran sigui un full d‚Äôestil, m√©s temps necessitar√† per descarregar-se i processar-se.
- [**Cap√ßaleres d‚Äôemmagatzematge a la mem√≤ria cau ben configurades**](https://simonhearne.com/2022/caching-header-best-practices/) ‚Äî Els fulls d‚Äôestil no s‚Äôhan de tornar a descarregar tret que es modifiquin. Les cap√ßaleres d‚Äôemmagatzematge a la cach√© permeten indicar als navegadors quan poden reutilitzar un full d‚Äôestil que ja han descarregat.
- [**Canvis de disseny¬†optimitzats**](https://web.dev/articles/optimize-cls) ‚Äî El contingut de la p√†gina hauria de tenir un canvi de disseny acumulatiu (*Cumulative Layout Shift, CLS*) m√≠nim o nul. √âs a dir, no hauria de ‚Äúmoure‚Äôs‚Äù ni ‚Äúdespla√ßar-se‚Äù inesperadament.
- [**Bones pr√†ctiques per l‚Äô√∫s de fonts**](https://web.dev/articles/font-best-practices) ‚Äî Les fonts tipogr√†fiques s'han de carregar el m√©s r√†pid possible i minimitzant el canvi de disseny acumulatiu.

Qu√® podem fer per aconseguir-ho?

- Netejar estils no utilitzats i comprimir fitxers CSS per empetitir-los.
- Generar noms de fitxers amb *hash* per un emmagatzematge a la cach√© segur.
- Agrupar fitxers CSS per tal de realitzar menys peticions a la xarxa.
- Prevenir les col¬∑lisions en els noms de classe per evitar les regresions visuals.
- Utilitzar sistemes tipus [BEM](https://getbem.com/) per posar noms de classe clars, f√†cils d‚Äôentendre i de mantenir.
- Definir dreceres i variables per tenir facilitat per adoptar el sistema de disseny o el/s tema/es.
- Rebre suggeriments de l'editor amb suport de TypeScript, autocompletat i *linting*.
- Rebre suggeriments de l'editor en temps de compilaci√≥ sobre com resoldre errors (per exemple, comprovaci√≥ de tipus, codi innaccessible, variables no utilitzades, *linting*...).

---

### CSS al 2024

El CSS va comen√ßar com un mode de separar el contingut de les p√†gines web del seu disseny. Amb el temps, ha evolucionat tant en complexitat com en capacitats fins al punt que mai havia estat tan f√†cil com ara escriure estils sense utilitzar eines addicionals.

Vegem un exemple r√†pid.

Aix√≠ √©s com funciona normalment l‚ÄôHTML i el CSS. S‚Äôaplica una classe a l‚ÄôHTML, i aquesta classe s‚Äôestilitza amb CSS. Sempre que aquest CSS s'apliqui al codi HTML, el color del tag `<h1>` ser√† blanc.

A m√©s, aquest codi utilitza algunes funcions avan√ßades de CSS (com [container queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_queries) i [nesting](https://developer.chrome.com/docs/css-ui/css-nesting)) compatibles amb el navegador sense cap pas de *build*.

<Playground
  files={{
    "/App.js": `export default function App() {
  return (
    <body>
      <header class="header">
        <h1>El meu blog</h1>
      </header>
      <main>
        <article class="article">
          <h2 class="article-title">CSS al 2024</h2>
          <p class="article-content">
            Mai havia estat tan f√†cil com ara escriure estils amb CSS! Aquest article aprofundeix en l‚Äôecosistema de CSS i en quines eines ens poden ser √∫tils.
          </p>
        </article>
        <article class="article">
          <h2 class="article-title">Utilitzant l'API de Notion amb Next.js</h2>
          <p class="article-content">
            Un tutorial sobre com crear una aplicaci√≥ Next.js fent servir l‚ÄôAPI privada de Notion com a backend.
          </p>
        </article>
        <article class="article">
          <h2 class="article-title">Com vaig crear el meu blog amb Next.js</h2>
          <p class="article-content">
            Una visi√≥ general de com vaig escollir les tecnologies, com vaig prendre decisions de disseny i quins recursos vaig trobar √∫tils.
          </p>
        </article>
      </main>
      <footer class="footer">
        <p>&copy; 2024 El meu blog</p>
      </footer>
    </body>
  )
}`,
    "/styles.css": {
      code: `:root {
  --bg-color: #1e90ff;
  --primary-text-color: #1a1e23;
  --secondary-text-color: #303741;
  --font-family: system-ui;
}

body {
  margin: 0;
  padding: 0;
  background-color: white;
  font-family: var(--font-family);
}

.header,
.footer {
  background-color: var(--bg-color);
  color: white;
  padding: 0.5rem 1rem;
  text-align: center;
}

.article {
  background-color: white;
  border: 1px solid whitesmoke;
  border-radius: 12px;
  container-type: inline-size;
  margin: 1rem;
  padding: 1rem;

  & .article-title {
    color: var(--primary-text-color);
    font-size: 1em;
    margin: 0 0 1rem 0;
    text-wrap: balance;
  }

  & .article-content {
    color: var(--secondary-text-color);
  }
}

@container (min-inline-size: 500px) {
  .article {
    padding: 1.5rem;

    & .article-title {
      font-size: 1.25em;
    }
  }
}`
    }    
  }}
/>

No obstant: aix√≤ no vol dir que no necessiteu eines com preprocessadors CSS, com Sass o Less. Dependr√† del context. Probablement, per complir els punts que ajuden a millorar l‚ÄôUX, la DX i la mantenibilitat dels estils comentats a l'apartat anterior, necessitareu un proc√©s de compilaci√≥.

#### Compilaci√≥

√âs poc probable que tots els vostres usuaris tinguin les √∫ltimes versions del navegador, per√≤, tot i aix√≠, sempre hi haur√† alguna nova sintaxi que encara no ser√† compatible amb tots els navegadors que voldreu utilitzar.

Podeu escriure manualment regles [@supports](https://developer.mozilla.org/en-US/docs/Web/CSS/@supports) per comprovar la compatibilitat amb els navegadors. Aix√≠, si una caracter√≠stica √©s adoptada per un navegador la podeu oferir, altrament podeu tenir un altre estil.

Per√≤, a part que aix√≤ nom√©s resol alguns problemes, si sou com jo, optimitzar manualment els fitxers de CSS us pot semblar una tortura. üòÖ

Per qu√® no deixar que ho gestioni un compilador?

#### CSS i React Server Components

‚ÄúReact Server Components‚Äù √©s un nou paradigma de React que ens ofereix un nou tipus de component, el *Server Component*. Els Server Components es renderitzen exclusivament en el servidor. El seu codi no s‚Äôinclou ni en els nostres *bundles* de JS.

A m√©s, al maig del 2023 Vercel va anunciar el llan√ßament de la versi√≥ estable de [Next.js 13](https://nextjs.org/blog/next-13-4), convertint-se en el primer *framework* de React construit sobre React Server Components.

Aix√≤ va suposar un gran qu√®! Que RSC (React Server Components) ofer√≠s oficialment una forma d‚Äôescriure codi exclusiu del servidor en React obria noves oportunitats.

Per√≤ no tot s√≥n flors i violes. RSC suposa un gran canvi en el funcionament de React, i algunes de les llibreries i eines existents s‚Äôhan hagut de refer o els segueix faltant suport.

Per exemple, les llibreries CSS-in-JS m√©s populars com styled-components i Emotion no s√≥n totalment compatibles amb aquesta nova visi√≥ de React, i realment √©s una mica trist el fet de no disposar d'un cam√≠ clar a seguir¬†al respecte.

Afortunadament, existeixen altres solucions CSS totalment compatibles amb els React Server Components que comentarem a continuaci√≥. Som-hi!

----
### El m√≥n de les solucions CSS

#### CSS modules

Si no esteu familiaritzats amb els CSS Modules, s√≥n una petita abstracci√≥ sobre CSS.

Aqu√≠ teniu un petit exemple:

<Playground
  files={{
    "/App.js": `import styles from './styles.module.css'
 
export default function App() {
  return <button className={styles.pinkButton}>Hello World</button>
}`,
"/styles.module.css": {
      code: `.pinkButton {
  background-color: pink;
  font-size: 2.25rem;
}`,
    }
  }}
/>

Segons la definici√≥ del [repositori](https://github.com/css-modules/css-modules) oficial, ‚ÄúUn CSS Module √©s un fitxer CSS on tots els noms de classe i d‚Äôanimaci√≥ tenen un √†mbit local per defecte‚Äù. Podeu tractar-los pr√†cticament com el CSS pur, per√≤ sense preocupar-vos de tenir noms de classe √∫nics a nivell global. Durant el pas de compilaci√≥, els noms gen√®rics com `.pinkButton` es transformen en noms √∫nics com `._20WEds96_Ee1ra54-24ePy`.

El m√©s important √©s que els CSS Modules compleixen la majoria dels punts que ajuden a [millorar l‚ÄôUX i la DX](https://www.smartido.dev/blog/css-al-2024#bones-pr√†ctiques-en-css). S√≥n una de les opcions m√©s populars que existeixen i **s√≥n compatibles amb pr√†cticament tots els *bundlers* i *frameworks* moderns** com Next.js.

#### Tailwind CSS

[Tailwind](https://tailwindcss.com/) utilitza un compilador per generar nom√©s les classes d‚Äôutilitat. √âs a dir, tot i que el¬†*framework*¬†inclou molts noms de classe, nom√©s s‚Äôinclouen a l‚Äôarxiu de CSS aquells que s‚Äôutilitzen (per exemple,¬†`text-2xl text-purple-400`).

El vostre¬†*bundle*¬†mai ser√† m√©s gran que les classes de Tailwind que utilitzeu. √âs molt¬†poc probable, per no dir gaireb√© impossible, que les utilitzeu totes. Per tant, l'arxiu de CSS generat tindr√† un tamany m√†xim fixat, que es reduir√†, comprimir√† i s‚Äôemmagatzemar√† a la cach√© per al millor rendiment.

A continuaci√≥ es mostra com es veuen els estils amb Tailwind:

<Playground
  files={{
    "/App.js": `export default function App() {
  return <h1 className="text-2xl text-purple-400">Hello World</h1>
}`
  }}
  options={{
    externalResources: ["https://cdn.tailwindcss.com"]
  }}
/>

Quan treballo amb CSS, intento que tots els estils d‚Äôun component determinat es trobin en un sol lloc. No em sembla pr√†ctic haver de buscar a trav√©s de tota l‚Äôaplicaci√≥ per trobar els CSS que podrien aplicar a un element determinat.

Aquest √©s un dels punts forts de Tailwind; tots els estils estan col¬∑locats junts, en el propi element. No ens hem de preocupar que hi hagi algun altre component que ‚Äúprengui‚Äù i apliqui els estils a un element que no li tocaria.

A m√©s, hi ha varis plugins i configuracions de Tailwind que en milloren la DX:

- [**Tailwind CSS IntelliSense**](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)¬†per autocompletar els noms de classes, remarcar la sintaxi i *linting*.
- [**Integraci√≥ amb Prettier**](https://tailwindcss.com/docs/editor-setup#automatic-class-sorting-with-prettier)¬†per ordenar autom√†ticament els noms de classes.

<Callout emoji="üí°">
  **Aprofundint m√©s**

  En aquest entrada de blog m'he centrat en els detalls de Tailwind m√©s rellevants per a poder entendre la comparaci√≥ i compatibilitat amb altres solucions de CSS. No obstant, si voleu saber m√©s sobre els avantatges i desavantatges de Tailwind, tinc una altra entrada al blog que els explora amb m√©s profunditat:

  [Com vaig crear el meu blog amb Next.js](https://www.smartido.dev/blog/com-vaig-crear-el-meu-blog-amb-nextjs#tailwind-css)
</Callout>

#### Llibreries CSS-in-JS

El fonament de les llibreries CSS-in-JS com [styled-components](https://styled-components.com/) o [Emotion](https://emotion.sh/docs/introduction) √©s que permeten escriure CSS directament dins dels components de React.

Aqu√≠ teniu un exemple r√†pid:

```tsx
import styled from 'styled-components';

const Title = styled.h1`
  font-size: 1.5em;
  text-align: center;
  color: tomato;
`;

export default function App() {
  return (
    <Title>
      Hello World!
    </Title>
  );
}
```

En comptes de col¬∑locar el CSS en una classe com `.title`, s‚Äôadjunta aquest CSS a un component React. Aix√≤ √©s el que fa especials els styled-components; els components s√≥n l‚Äôelement reutilitzable, no les classes.

`styled.h1`¬†√©s una funci√≥ que genera din√†micament un nou component de React, i assignem aquest component a una variable anomenada¬†`Title`. Llavors podem utilitzar aquest component de React de la mateixa manera que utilitzariem qualsevol altre component de React. Renderitzar√† un tag¬†`<h1>`¬†que t√© un text vermell.

Quan estenem el model mental dels components al nostre CSS, guanyem sobretot dos aspectes claus:

- La capacitat de saber, amb seguretat, si √©s segur eliminar una declaraci√≥ CSS (no hi ha la possibilitat que afecti a una altra part de l‚Äôaplicaci√≥).
- Una manca total de problemes d'especificat alhora d‚Äôaplicar estils (no hi ha la possibilitat que una declaraci√≥ tingui zero efecte perqu√® un altre estil l‚Äôestigui sobreescrivint, o sigui ‚Äúm√©s espec√≠fic‚Äù que un altre i el guanyi).

#### Llibreries Zero-Runtime CSS-in-JS

Hi ha 2 desavantatges amb la majoria de llibreries CSS-in-JS:

1. Existeix una incompatibilitat fonamental entre els React Server Components i les llibreries CSS-in-JS, consistent en qu√® aquestes llibreries estan dissenyades per executar-se en el navegador, mentre que els React Server Components mai toquen el navegador.

2. Les llibreries CSS-in-JS ens permeten crear de forma din√†mica components de React amb CSS adjunt. Funcionen convertint els estils escrits en JS en CSS cada cop que el component es renderitza. Aix√≤ t√© un cost d‚Äôexecuci√≥ i √©s el motiu pel qual aquestes llibreries estan passant a ser ‚Äúzero runtime‚Äù.

Per resoldre aquestes q√ºestions, s‚Äôestan desenvolupant varies llibreries que ofereixen una API semblant als styled-components, per√≤ amb total compatibilitat amb els React Server Components! ‚ú®

En comptes d‚Äôestar lligades al cicle de vida de React, aquestes eines han adoptat un enfocament diferent; tot el processament es realitza en temps de compilaci√≥.

Les aplicacions modernes de React tenen un pas de *build*, on convertim TypeScript/JSX en JavaScript i empaquetem milers de fitxers individuals en un grapat de paquets. Aix√≤ es produeix quan es desplega la nostra aplicaci√≥, abans que comenci a executar-se en producci√≥. Per qu√® no processem els nostres components amb els estils durant aquest pas, en comptes de fer-ho en temps d'execuci√≥?

Aquesta √©s la idea central rere totes les llibreries ‚Äúzero runtime‚Äù. Aqu√≠ teniu una petita llista amb alguns projectes interessants:

- [Linaria](https://github.com/callstack/linaria) ‚Äî Creada al 2017, Linaria √©s una llibreria que durant el pas de *build* transforma el codi i mou tots els estils a CSS Modules. Nosaltres escribim styled-components, i Linaria els preprocessar√† en CSS Modules, que despr√©s es processaran en CSS pur. Tot aix√≤ passa en temps de compilaci√≥. El m√©s important √©s que, com hem vist, CSS Modules tenen molt suport
- [Panda CSS](https://github.com/chakra-ui/panda) ‚Äî Aquesta llibreria est√† desenvolupada per la gent que va crear Chakra UI, una biblioteca de components for√ßa popular. Igual que Linaria, Panda CSS es compila. per√≤ en comptes de compilar-se en CSS Modules es compila en classes d‚Äôutilitat semblants a les de Tailwind.
- [StyleX](https://github.com/facebook/stylex/) ‚Äî Utilitzada per totes les p√†gines de Meta: Facebook, Instagram, WhatsApp, i Threads. StyleX utilitza un plugin de Babel per trobar i extreure els estils i convertir-los en classes at√≤miques en temps de compilaci√≥.

---

### Conclusi√≥

Quina aproximaci√≥ haurieu de fer servir? No ho s√©. üòÖ

Cada enfocament t√© els seus avantatges i inconvenients. Dep√®n totalment del context en el qual estigueu desenvolupant. L‚Äôimportant √©s seleccionar les eines que ens permetran desenvolupar millor, a un bon ritme i tenint en compte tot el context.

Finalment, no oblideu que els navegadors web nom√©s entenen el CSS pur. Totes les eines maravelloses que utilitzeu (CSS Modules, Tailwind, llibreries CSS-in-JS, Bootstrap, Sass) produeixen Vanilla CSS pel navegador. Si voleu ser productius amb aquestes eines, necessiteu entendre com funciona CSS.


